# MPC Development Log for UR20 Mobile Manipulation
## Project Overview
- **Goal**: Develop a Model Predictive Controller (MPC) for stabilizing a UR20 robot arm's end-effector while mounted on a mobile platform
- **Platform**: Mobile base with two differential wheels and two caster wheels
- **Robot**: Universal Robots UR20 manipulator
- **Framework**: ROS (Robot Operating System)

## Current Implementation Status

### 1. Initial Setup (Completed)
- Created ROS package structure
- Implemented basic action server/client architecture
- Set up configuration system using YAML
- Established base motion simulation for testing

### 2. MPC Controller Development (In Progress)
#### 2.1 Implemented Components:
- **State Space Definition**
  - Joint positions (6 DOF)
  - Joint velocities (6 DOF)
  - End-effector pose (position + orientation)
  - Base motion state (position, orientation, velocities)

- **System Dynamics**
  - Forward kinematics using MoveIt
  - Jacobian-based velocity mapping
  - State prediction over horizon
  - Base motion prediction

- **Cost Function Components**
  - End-effector position tracking
  - Orientation maintenance
  - Control effort minimization
  - Smoothness terms

- **Constraints**
  - Joint position limits
  - Joint velocity limits
  - Dynamic feasibility constraints

#### 2.2 Current Performance:
- Fast execution (50Hz control rate achieved)
- Successful base motion compensation
- Issues remaining:
  1. Oscillations during steady state
  2. Orientation drift
  3. Non-optimal smoothness in trajectories

### 3. Parameter Tuning Progress
- **Initial Parameters**:
  ```yaml
  horizon: 3
  dt: 0.05
  weights:
    position: 10.0
    orientation: 3.0
    control: 0.1
  smoothness:
    enabled: true
    weight: 0.5
  ```

## Next Steps

### 1. Stability Improvements
- [ ] Add damping terms to cost function
- [ ] Implement better steady-state handling
- [ ] Enhance orientation control weights
- [ ] Add acceleration constraints

### 2. Trajectory Smoothing
- [ ] Implement velocity profile generation
- [ ] Add jerk minimization terms
- [ ] Improve warm starting strategy

### 3. Orientation Control
- [ ] Separate position and orientation control weights
- [ ] Implement quaternion-based orientation control
- [ ] Add orientation-specific smoothness terms

### 4. Performance Optimization
- [ ] Profile computation bottlenecks
- [ ] Optimize prediction horizon length
- [ ] Implement parallel computation where possible

## Technical Details

### Key Files:
1. `ur_mpc.py`: Main MPC implementation
2. `ur20_dynamics.py`: Robot dynamics and kinematics
3. `mpc_action_server.py`: ROS action server implementation
4. `controller_params.yaml`: Configuration parameters

### Current Architecture:
MPC Controller
├── State Estimation
│   ├── Joint States
│   ├── End-effector Pose
│   └── Base Motion
├── Prediction
│   ├── System Dynamics
│   └── Base Motion
└── Optimization
    ├── Cost Function
    ├── Constraints
    └── Control Generation
### Implementation Details:
1. **Optimization Method**: SLSQP (Sequential Least Squares Programming)
2. **Update Rate**: 50Hz
3. **Prediction Horizon**: 3 steps
4. **State Dimension**: 18 (6 joints × [position, velocity] + 6 EE pose)
5. **Control Dimension**: 6 (joint velocities)

## Known Issues
1. **Oscillations**:
   - Occurs during steady state
   - Present even without base motion
   - Possibly due to aggressive control gains

2. **Orientation Control**:
   - Insufficient orientation tracking
   - Drift during motion compensation

3. **Trajectory Smoothness**:
   - Non-optimal velocity profiles
   - Jerky motions during direction changes

## Future Improvements
1. **Stability**:
   - Implement LQR terminal cost
   - Add integral action for steady-state
   - Improve numerical conditioning

2. **Performance**:
   - Implement C++ core components
   - Optimize matrix operations
   - Add multi-threading support

3. **Features**:
   - Add predictive collision avoidance
   - Implement adaptive base motion prediction
   - Add online parameter adaptation

## References
1. MoveIt for kinematics
2. ROS Control for joint trajectory execution
3. scipy.optimize for optimization
4. numpy for numerical computations

## Testing Instructions
1. Launch MPC controller:
   ```bash
   roslaunch ur20_mpc_controller mpc_controller.launch
   ```
2. Run base motion simulation:
   ```bash
   rosrun ur20_mpc_controller test_base_observer.py
   ```
3. Start client:
   ```bash
   rosrun ur20_mpc_controller mpc_action_client.py
   ```

## Maintainers
- Initial Development: [Your Name]
- Last Updated: [Current Date]
